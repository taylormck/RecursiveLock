/*
 * Created on Jan 31, 2004
 *
 * This work is unwarranted.
 */

/**
 * @author Ronald L. Rockhold
 */

/*
 * Modified on Jan 19, 2005
 */

/**
 * @author Cara Kenny
 */
package cs439.lab2.simulator;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Properties;
import java.util.Random;
import java.util.StringTokenizer;

/**
 * Title:        
 * Description:
 * Copyright:    Copyright (c) 2012
 * Company:      University of Texas at Austin
 * @author R.L. Rockhold, Ph.D.
 * @version 1.0
 */

public class PCB {
	
	/**
	 * IDs are generated by Simulator.  The first process
	 * is id=0, next is 1.
	 * @return This process' id
	 */
	public Integer getPID() {
		return this.pid;
	}

	/**
	 * The Simulator gives each process a name.  This name
	 * is the same value found in the configuration file for
	 * property "Processes"
	 * @return this process' name
	 */
	public String getName() {
		return this.name;
	}
	
	/**
	 * Changes the quantum associated with this process.
	 * This change persists until the next setQuantum() call.
	 * When a process is dispatched (IScheduler.schedule()), the
	 * CPU retrieves the quantum from the process.
	 * @param ticks  quantum size
	 */
	public void setQuantum(final int ticks) {
		this.quantum = ticks;
	}
	
	/**
	 * Returns the number of ticks in the current quantum assigned to this process.
	 * Default quantum is 4 ticks.  Use setQuantum(number-of-tics) to change.
	 * When a process is dispatched (IScheduler.schedule()), the
	 * CPU retrieves the quantum from the process.
	 * @return quantum in ticks.
	 */
	public int getQuantum() {
		return this.quantum;
	}
	
	/**
	 * Associates the object o with this Process.
	 * Since only 1 object can be associated with a Process,
	 * this replaces any previously set Object or the default (null).
	 * @param o
	 */
    public void setObject(final Object o) {
        this.object = o;
    }

    /**
	 * Retrieves the current Object associated with this IProcess.
	 * @return Object, or null.
	 */
    public Object getObject() {
        return this.object;
    }

	Integer pid;
 	private Random rand;
 	// Set to true when we kill a processes that has pending I/O.
 	boolean marked_for_death;
 	private int context_switches = 0;
	private int current_burst;
	private boolean current_burst_exists = false;
	private int executed_ticks = 0;
	private int execution_burst_count = 0;
	private String infile_name;
	boolean is_started = false;
	private String name;
	private int next_trace_index = 0;
	private final List<Integer> past_bursts = new LinkedList<Integer>();
	private final Properties props = new Properties();
	private int quantum = 5;
	private int remaining_burst;
	private int started_time;
	private final ArrayList<Integer> trace = new ArrayList<Integer>();
    private Object object = null;
	
	PCB(final int id, final String proc_name, final String infile_name, final Integer i_start) throws IOException {
		this.pid = new Integer(id);
		this.name = proc_name;
		this.infile_name = infile_name;
		this.buildTrace();
		final String disp = "Trace for process " + this.name + "(" + id + ") starts at tick " + i_start + ": " + this.trace.toString();
		if (this.trace.size() < 100) {
			Debug.log(disp);
		} else {
			Debug.info(disp);
		}
	}
 	
 	PCB(final int _pid) {
 		this.pid = new Integer(_pid);
 		this.rand = new Random(_pid);
 		this.marked_for_death = false;
 	}
      
 	PCB(final Integer _pid) {
 		this.pid = new Integer(_pid.intValue());
 		this.rand = new Random(_pid.intValue());
 		this.marked_for_death = false;
 	}
 	
 	private void buildTrace() throws IOException {
		final FileInputStream in = new FileInputStream(this.infile_name + ".properties");
		this.props.load(in);
		this.addTraceForTag("ROOT");
		this.trace.add(new Integer(Integer.MAX_VALUE));
	}
 	
 	private void addBurst(Integer burst) {
		int i_burst = burst.intValue();
		if (i_burst == 0) {
			Debug.log(
				"Cowardly refusing to add a burst of 0. " + this.infile_name);
			return;
		}
		final int size = this.trace.size();
		if (size > 0) {
			//  Check for combining
			final Integer prev = (Integer) this.trace.remove(size - 1);
			final int i_prev = prev.intValue();
			if (((i_burst > 0) && (i_prev > 0)) || ((i_burst < 0) && (i_prev < 0))) {
				Debug.log(
					"Combining consective bursts of "
						+ i_prev
						+ " and "
						+ i_burst
						+ " "
						+ this.infile_name);
				i_burst += i_prev;
				burst = new Integer(i_burst);
			} else {
				this.trace.add(prev); // put it back
			}
		} else {
			
			// Make sure the first burst is positive (cpu time)
			if (i_burst < 0) {
				Debug.log(
					"*****  Error  ***** First burst must be for CPU, not I/O "
						+ i_burst
						+ " "
						+ this.infile_name);
				return;
			}
			
		}
		this.trace.add(burst);
	}
 	
 	private void addTraceForSequence(final String s) {
		final StringTokenizer stk = new StringTokenizer(s);
		while (stk.hasMoreTokens()) {
			final String elem = stk.nextToken();
			if (elem.startsWith("#")) {
				break;
			}
			Integer burst;
			try {
				burst = Integer.valueOf(elem);
				this.addBurst(burst);
			} catch (final NumberFormatException e) {
				this.addTraceForTag(elem);
			}
		}
	}
 	
 	private void addTraceForTag(final String tag) {
		final String base = this.props.getProperty(tag + ".TR").trim();
		if (base == null) {
			throw new IllegalArgumentException(
				"Trace input file "
					+ this.infile_name
					+ " is missing the "
					+ tag
					+ ".TR property.");
		}
		final String reps_s = this.props.getProperty(tag + ".REPS", "1").trim();
		final int reps = Integer.parseInt(reps_s);
		for (int rep = 0; rep < reps; ++rep) {
			this.addTraceForSequence(base);
		}
	}
 	
 	void completed(final int current_time) {
		SchedStats.finishedData(
			this,
			this.started_time,
			current_time,
			this.executed_ticks,
			this.execution_burst_count,
			this.context_switches);
	}
 	
 	@Override
	public String toString() {
 		String s = this.name + "(" + this.pid + ")";
 		if(this.marked_for_death) {
 			s += " (marked)";
 		}
 		return s;
 	}
      
 	void do_compute(final byte[] buffer) {
 		this.rand.nextBytes(buffer);
 		// page_bytes does not need to be copied back because we wrote
 		// into a reference to an array
 	}
 	
 	List<Integer> getBurstHistory() {
		return Collections.unmodifiableList(this.past_bursts);
	}
 	
	int getRemainingCPUBurst() {
		if (this.current_burst_exists) {
			return this.remaining_burst;
		}
		final Integer burst = this.trace.get(this.next_trace_index);
		++this.next_trace_index;
		this.current_burst = burst.intValue();
		if (this.current_burst == Integer.MAX_VALUE) {
			return this.current_burst;
		}
		if (this.current_burst < 0) { // I/O
			this.past_bursts.add(0, new Integer(this.current_burst));
			return this.current_burst;
		} else {
			++this.execution_burst_count;
			this.current_burst_exists = true;
			this.remaining_burst = this.current_burst;
			return this.remaining_burst;
		}
	}

	void incrCPUTime(final int ticks) {
		if (!this.current_burst_exists) {
			throw new IllegalStateException("Called with no burst time remaining.");
		}
		if (ticks > this.remaining_burst) {
			throw new IllegalStateException(
				"ticks "
					+ ticks
					+ " exceeds remaining burst "
					+ this.remaining_burst);
		}
		this.executed_ticks += ticks;
		this.remaining_burst -= ticks;
		if (this.remaining_burst == 0) {
			this.past_bursts.add(0, new Integer(this.current_burst));
			this.current_burst_exists = false;
		}
	}
	
	int peekRemainingCPUBurst() {
		if (this.current_burst_exists) {
			return this.remaining_burst;
		}
		final Integer burst = this.trace.get(this.next_trace_index);
		this.current_burst = burst.intValue();
		return this.current_burst;
	}
	
	boolean isStarted() {
		return this.is_started;
	}

	void started(final int current_time) {
		this.started_time = current_time;
		Debug.log("Process " + this + " started at time " + current_time);
		this.is_started = true;
	}

    void incrDispatches() {
		++this.context_switches;
    }

 	
}
